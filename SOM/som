import math

from minisom import MiniSom
from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
from sklearn import datasets
MAX_ITER = 200


def get_data(test_size=0.3,random_state=0):
    iris = datasets.load_iris()
    feature_names = iris.feature_names
    class_names = iris.target_names

    X = iris.data
    y = iris.target
    #7：3划分
    return train_test_split(X,y,test_size=test_size,random_state=random_state)

train_data, test_data, train_labels, test_labels = get_data()
N = train_data.shape[0]  #样本数量
M = train_data.shape[1]  #维度/特征数量

size = math.ceil(np.sqrt(5 * np.sqrt(N)))  # 经验公式：决定输出层尺寸

som = MiniSom(size, size, M, sigma=3, learning_rate=0.5,neighborhood_function='gaussian')
som.random_weights_init(train_data) #随机初始化

som.train_batch(train_data,MAX_ITER,verbose=False)

#labels_map利用标签信息，标注训练好的Som网络：
winmap=som.labels_map(train_data,train_labels)
# [x1,x2]:counter{1:2,2:1} x1,x1出现第一类 第二类的次数

#根据训练时 激活神经元的总类的比例 决定这个神经元属于哪一类
def classify(som,data,winmap):
    from numpy import sum as npsum
    default_class = npsum(list(winmap.values())).most_common()[0][0]
    result = []
    for d in data:
        win_position = som.winner(d)
        if win_position in winmap:
            result.append(winmap[win_position].most_common()[0][0])
        else:
             result.append(default_class)
    return result


pred_labels = classify(som,test_data,winmap)
#前行的类别在测试数据中的样本总量
print(classification_report(test_labels, np.array(pred_labels)))

heatmap = som.distance_map()
plt.imshow(heatmap, cmap='bone_r')
plt.colorbar()
plt.show()
# 在矩阵中标记输入的值
plt.figure(figsize=(9, 9))
plt.pcolor(heatmap, cmap='bone_r')  # 设置背景
markers = ['o', 's', 'D']
colors = ['C0', 'C1', 'C2']
category_color = {'setosa': 'C0',
                  'versicolor': 'C1',
                  'virginica': 'C2'}
for cnt, xx in enumerate(train_data):
    w=som.winner(xx)
    plt.plot(w[0]+.5, w[1]+.5, markers[train_labels[cnt]], markerfacecolor='None',
             markeredgecolor=colors[train_labels[cnt]], markersize=12, markeredgewidth=2)
plt.axis([0, size, 0, size])
ax = plt.gca()
ax.invert_yaxis()
legend_elements = [Patch(facecolor=clr,
                         edgecolor='w',
                         label=l) for l, clr in category_color.items()]
plt.legend(handles=legend_elements, loc='center left', bbox_to_anchor=(1, .95))
plt.show()